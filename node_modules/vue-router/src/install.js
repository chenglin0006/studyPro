import View from './components/view'
import Link from './components/link'

//export一个vue的引用，这样做是因为插件在打包的时候不希望把 vue 作为一个依赖包打进去的，但是又希望使用 Vue 对象本身的一些方法
export let _Vue

export function install (Vue) {
  if (install.installed) return
  install.installed = true
  //赋值私有vue的引用
  _Vue = Vue

  //注入$router,$route这两个参数,使得所有的组件都可以访问到这个实例原型上定义的属性。
  Object.defineProperty(Vue.prototype, '$router', {
    get () { return this.$root._router }
  })

  Object.defineProperty(Vue.prototype, '$route', {
    get () { return this.$root._route }
  })

  //在实例化vue的时候会调这里的beforeCreate方法进行一系列的初始化操作
  Vue.mixin({
    beforeCreate () {
      //判断是否有router配置
      if (this.$options.router) {
        //赋值router，这样在访问原型上的 $router 的时候就可以得到 router 了
        this._router = this.$options.router
        //初始化router
        this._router.init(this)
        //定义响应式的_route对象，
        //一旦 history 发生改变就会触发更新机制调用应用实例的 render 方法进行重新渲染
        //所以每次路由切换之后组件也会重新渲染
        Vue.util.defineReactive(this, '_route', this._router.history.current)
      }
    }
  })

  //注册组件
  Vue.component('router-view', View)
  Vue.component('router-link', Link)

  const strats = Vue.config.optionMergeStrategies
  // use the same hook merging strategy for route hooks
  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.created
}
