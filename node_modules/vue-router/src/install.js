import View from './components/view'
import Link from './components/link'

//export一个vue的引用，插件在打包的时候不希望把 vue 作为一个依赖包打进去的，但是又希望使用 Vue 对象本身的一些方法
export let _Vue

export function install (Vue) {
  if (install.installed) return
  install.installed = true
  //赋值私有vue引用
  _Vue = Vue

  //注入$router,$route,在 Vue.js 中所有的组件都是被扩展的 Vue 实例，也就意味着所有的组件都可以访问到这个实例原型上定义的属性。
  Object.defineProperty(Vue.prototype, '$router', {
    get () { return this.$root._router }
  })

  Object.defineProperty(Vue.prototype, '$route', {
    get () { return this.$root._route }
  })

  Vue.mixin({
    beforeCreate () {
      //判断是否有router配置
      if (this.$options.router) {
        //赋值router，这样在访问原型上的 $router 的时候就可以得到 router 了
        this._router = this.$options.router
        //初始化router
        this._router.init(this)
        //定义响应式的_route对象，history 每次更新成功后都会去更新应用实例的 _route 的值，一旦 history 发生改变就会触发更新机制调用应用实例的 render 方法进行重新渲染
        Vue.util.defineReactive(this, '_route', this._router.history.current)
      }
    }
  })

  //注册组件
  Vue.component('router-view', View)
  Vue.component('router-link', Link)

  const strats = Vue.config.optionMergeStrategies
  // use the same hook merging strategy for route hooks
  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.created
}
